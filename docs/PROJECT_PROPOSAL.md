# Практическая работа №6
## Проектное предложение: Система рекомендаций для книжного интернет-магазина

---

### 1. Обзор проекта

**Название проекта:** Bookstore Recommendation System

**Цель проекта:** Разработка полнофункционального интернет-магазина книг с интеллектуальной системой персональных рекомендаций на основе collaborative filtering и content-based алгоритмов.

**Область применения:** E-commerce, книжная торговля, рекомендательные системы

---

### 2. Выбор NoSQL базы данных

#### 2.1 Выбранная БД: MongoDB

**Обоснование выбора:**

1. **Гибкая схема данных**
   - Документная модель позволяет легко изменять структуру данных без миграций
   - Идеально подходит для хранения разнородных атрибутов книг
   - Поддержка вложенных документов для метаданных взаимодействий

2. **Масштабируемость**
   - Горизонтальное масштабирование через шардинг
   - Репликация для высокой доступности
   - Подходит для роста каталога и базы пользователей

3. **Производительность**
   - Быстрые запросы благодаря индексам
   - Агрегация для аналитики и рекомендаций
   - Асинхронные операции через Motor/Beanie

4. **Экосистема**
   - Отличная поддержка Python (PyMongo, Motor, Beanie)
   - MongoDB Atlas для облачного развертывания
   - Богатая документация и сообщество

**Альтернативы, которые были рассмотрены:**

- **Redis**: Отличная производительность, но ограниченная персистентность и сложность работы со сложными запросами
- **Neo4j**: Хорош для графовых связей, но избыточен для нашей задачи и сложнее в освоении
- **Cassandra**: Отличная масштабируемость, но чрезмерна для проекта такого масштаба

---

### 3. Подход к моделированию данных

#### 3.1 Модель данных

Проект использует **документно-ориентированную модель** с следующими коллекциями:

**1. Коллекция Users (Пользователи)**
```javascript
{
  _id: ObjectId,
  email: String (unique, indexed),
  username: String (unique, indexed),
  hashed_password: String,
  full_name: String,
  is_active: Boolean,
  is_superuser: Boolean,
  created_at: DateTime,
  favorite_genres: [String],      // Массив любимых жанров
  favorite_authors: [String]      // Массив любимых авторов
}
```

**Индексы:**
- `email` (unique)
- `username` (unique)
- Compound index: `(is_active, created_at)`

**2. Коллекция Books (Книги)**
```javascript
{
  _id: ObjectId,
  title: String (indexed),
  author: String (indexed),
  description: String,
  genre: String (indexed),
  price: Float,
  stock: Integer,
  isbn: String (unique),
  publisher: String,
  publication_year: Integer,
  pages: Integer,
  language: String,
  cover_image: String,
  average_rating: Float,
  ratings_count: Integer,
  tags: [String],                 // Массив тегов для content-based filtering
  is_featured: Boolean,
  discount_percentage: Float,
  created_at: DateTime (indexed)
}
```

**Индексы:**
- `title` (text index для полнотекстового поиска)
- `author` (для фильтрации по автору)
- `genre` (для фильтрации по жанру)
- `isbn` (unique)
- `created_at` (для сортировки по новизне)
- Compound index: `(genre, average_rating)` для быстрой выборки популярных книг по жанру

**3. Коллекция Interactions (Взаимодействия)**
```javascript
{
  _id: ObjectId,
  user_id: ObjectId (indexed),
  book_id: ObjectId (indexed),
  interaction_type: String,       // "view", "like", "add_to_cart", "purchase", "review"
  timestamp: DateTime (indexed),
  metadata: {
    duration: Integer,            // Для просмотров
    quantity: Integer,            // Для покупок
    price_at_purchase: Float,     // Цена на момент покупки
    rating: Float,                // Оценка (1-5)
    review_text: String           // Текст отзыва
  }
}
```

**Индексы:**
- `user_id`
- `book_id`
- `timestamp` (для временных запросов)
- Compound indexes:
  - `(user_id, book_id)` - для быстрого поиска взаимодействий пользователя с книгой
  - `(user_id, book_id, interaction_type)` - для специфичных запросов
  - `(book_id, timestamp)` - для аналитики по книгам

**4. Коллекция Orders (Заказы)**
```javascript
{
  _id: ObjectId,
  user_id: ObjectId (indexed),
  items: [
    {
      book_id: ObjectId,
      quantity: Integer,
      price: Float
    }
  ],
  total_amount: Float,
  status: String,                 // "pending", "confirmed", "shipped", "delivered"
  created_at: DateTime (indexed),
  updated_at: DateTime
}
```

**5. Коллекция Cart (Корзина)**
```javascript
{
  _id: ObjectId,
  user_id: ObjectId (unique, indexed),
  items: [
    {
      book_id: ObjectId,
      quantity: Integer,
      added_at: DateTime
    }
  ],
  updated_at: DateTime
}
```

#### 3.2 Преимущества выбранного подхода

1. **Денормализация для производительности**
   - Хранение `average_rating` и `ratings_count` непосредственно в документе книги избавляет от необходимости агрегации при каждом запросе
   - Метаданные взаимодействий хранятся в одном документе

2. **Гибкость схемы**
   - Легко добавлять новые поля без миграций
   - Metadata в Interactions позволяет хранить различные данные для разных типов взаимодействий

3. **Эффективность запросов**
   - Индексы оптимизированы под частые запросы
   - Compound индексы для сложных фильтров

4. **Масштабируемость**
   - Коллекция Interactions может расти неограниченно
   - Возможность шардинга по `user_id` для распределения нагрузки

#### 3.3 Компромиссы (Trade-offs)

**Преимущества:**
- ✅ Быстрые чтения благодаря денормализации
- ✅ Гибкая схема для экспериментов
- ✅ Простота разработки

**Недостатки:**
- ❌ Дублирование данных (например, данные о книге в заказах)
- ❌ Необходимость обновления рейтингов в нескольких местах
- ❌ Отсутствие транзакций между коллекциями (частично решено через MongoDB transactions)

---

### 4. Алгоритм рекомендаций

#### 4.1 Гибридный подход

Система использует **гибридный подход**, комбинирующий три метода:

1. **Collaborative Filtering (User-Based)**
2. **Content-Based Filtering**
3. **Popularity-Based Recommendations**

#### 4.2 Collaborative Filtering (Коллаборативная фильтрация)

**Тип:** User-based collaborative filtering

**Алгоритм:**

1. **Построение матрицы User-Item**
   ```
   Матрица M размером (N_users × N_books)
   где M[i][j] = взвешенная сумма взаимодействий пользователя i с книгой j
   ```

2. **Веса взаимодействий:**
   - VIEW: 1.0
   - LIKE: 3.0
   - ADD_TO_CART: 5.0
   - REMOVE_FROM_CART: -2.0
   - PURCHASE: 10.0
   - REVIEW: 8.0 + rating

3. **Вычисление сходства пользователей**
   ```
   similarity(user_A, user_B) = cosine_similarity(vector_A, vector_B)
   
   где cosine_similarity = (A · B) / (||A|| × ||B||)
   ```

4. **Генерация рекомендаций**
   
   Для целевого пользователя U:
   
   ```
   score(book_j) = Σ (similarity(U, user_i) × rating(user_i, book_j) × book_rating) / popularity_penalty
   
   где:
   - similarity(U, user_i) - сходство с другими пользователями
   - rating(user_i, book_j) - взвешенная оценка взаимодействий
   - book_rating - средний рейтинг книги
   - popularity_penalty = 1 + log(1 + popularity) - снижает вес популярных книг
   ```

5. **Фильтрация**
   - Исключаем книги, с которыми пользователь уже взаимодействовал
   - Сортируем по убыванию score

**Преимущества:**
- ✅ Находит неожиданные, но релевантные рекомендации
- ✅ Учитывает поведение похожих пользователей
- ✅ Не требует анализа содержимого книг

**Недостатки:**
- ❌ Cold start problem для новых пользователей
- ❌ Требует значительный объем данных о взаимодействиях
- ❌ Вычислительно затратный при большом количестве пользователей

#### 4.3 Content-Based Filtering

**Алгоритм:**

1. **Векторизация признаков книги**
   - Жанр (категориальный признак)
   - Автор (категориальный признак)
   - Теги (TF-IDF векторизация)

2. **Вычисление сходства**
   ```
   score(book_candidate) = 
     3.0 × (genre_match ? 1 : 0) +
     5.0 × (author_match ? 1 : 0) +
     5.0 × cosine_similarity(tags_target, tags_candidate) +
     1.5 × count(shared_tags) +
     average_rating / 5.0
   ```

3. **Оптимизация**
   - Сначала отбираем кандидатов по жанру (ограничение до 250 книг)
   - Затем вычисляем детальное сходство

**Применение:**
- Рекомендации "Похожие книги" на странице книги
- Fallback для новых пользователей по их любимым жанрам

#### 4.4 Popularity-Based Recommendations

**Алгоритм:**

1. **Вычисление популярности с учетом времени**
   ```
   score(book_j) = Σ (weight(interaction) × recency_multiplier × book_rating)
   
   где:
   - weight(interaction) - вес типа взаимодействия
   - recency_multiplier = 1 / (1 + days_since_interaction)
   - book_rating - средний рейтинг книги
   ```

2. **Временные окна**
   - По умолчанию: последние 7 дней
   - Для трендов: последние 24 часа

**Применение:**
- Раздел "Популярное"
- Рекомендации для новых пользователей
- Fallback когда другие методы не дают результатов

#### 4.5 Обработка Cold Start

**Стратегия для новых пользователей:**

1. Если указаны любимые жанры → выбираем топ книги по этим жанрам (60% квоты)
2. Добавляем трендовые книги (30% квоты)
3. Добавляем новинки (10% квоты)

**Стратегия для новых книг:**

1. Content-based рекомендации по жанру и автору
2. Показываем в разделе "Новинки"
3. Включаем в результаты поиска с приоритетом

---

### 5. Технологический стек

#### Backend
- **Framework:** FastAPI 0.115.0
- **Database:** MongoDB 4.4+
- **ODM:** Beanie 1.27.0 (асинхронный)
- **Authentication:** JWT (python-jose)
- **Security:** Passlib with bcrypt
- **ML Libraries:** scikit-learn 1.5.0, NumPy 1.26.0, Pandas 2.2.0
- **Server:** Uvicorn (ASGI)

#### Frontend
- **Framework:** React 18
- **Build Tool:** Vite
- **Styling:** Tailwind CSS
- **State Management:** Zustand
- **Data Fetching:** TanStack Query (React Query)
- **Routing:** React Router v6
- **HTTP Client:** Axios
- **UI Components:** Lucide React, React Hot Toast

#### Testing & Performance
- **Load Testing:** Locust 2.31.8
- **Unit Testing:** Pytest 8.3.3
- **Async Testing:** pytest-asyncio
- **HTTP Testing:** httpx

---

### 6. Архитектура системы

```
┌─────────────────────────────────────────────────────────────┐
│                         Frontend (React)                     │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐   │
│  │  Catalog │  │  Search  │  │  Profile │  │   Cart   │   │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘   │
│  ┌──────────────────────────────────────────────────────┐  │
│  │         Recommendation Components                     │  │
│  │  (PersonalFeed, Similar, Trending, Discovery)        │  │
│  └──────────────────────────────────────────────────────┘  │
└────────────────────────┬────────────────────────────────────┘
                         │ REST API (JSON)
                         │
┌────────────────────────▼────────────────────────────────────┐
│                    Backend (FastAPI)                         │
│  ┌──────────────────────────────────────────────────────┐  │
│  │              API Endpoints Layer                      │  │
│  │  /auth  /books  /cart  /orders  /recommendations     │  │
│  └────────────────────┬─────────────────────────────────┘  │
│                       │                                     │
│  ┌────────────────────▼─────────────────────────────────┐  │
│  │           Business Logic Layer                        │  │
│  │  ┌──────────────┐  ┌────────────────────────────┐   │  │
│  │  │ Auth Service │  │  Recommendation Engine      │   │  │
│  │  └──────────────┘  │  - Collaborative Filtering  │   │  │
│  │                    │  - Content-Based           │   │  │
│  │                    │  - Popularity-Based        │   │  │
│  │                    └────────────────────────────┘   │  │
│  └────────────────────┬─────────────────────────────────┘  │
│                       │                                     │
│  ┌────────────────────▼─────────────────────────────────┐  │
│  │               Data Access Layer (Beanie ODM)          │  │
│  └────────────────────┬─────────────────────────────────┘  │
└────────────────────────┼─────────────────────────────────────┘
                         │
┌────────────────────────▼─────────────────────────────────────┐
│                      MongoDB Database                         │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐    │
│  │  Users   │  │  Books   │  │  Inter-  │  │  Orders  │    │
│  │          │  │          │  │ actions  │  │          │    │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘    │
└──────────────────────────────────────────────────────────────┘
```

---

### 7. Ключевые особенности реализации

#### 7.1 Асинхронность
- Все операции с БД асинхронные (async/await)
- Параллельная обработка запросов
- Неблокирующий I/O для высокой производительности

#### 7.2 Индексирование
- Compound индексы для сложных запросов
- Text индексы для полнотекстового поиска
- Индексы на все часто используемые поля

#### 7.3 Оптимизация запросов
- Пагинация для больших результатов
- Проекции для выборки только нужных полей
- Батчевые операции для массовых вставок

#### 7.4 Кэширование (планируется)
- Redis для кэширования рекомендаций
- TTL для автоматического обновления
- Инвалидация при изменении данных

#### 7.5 Безопасность
- JWT токены с истечением
- Хеширование паролей (bcrypt)
- CORS настройки
- Валидация входных данных (Pydantic)

---

### 8. План тестирования производительности

#### 8.1 Метрики

**Ключевые метрики:**
- Response Time (время ответа)
- Throughput (пропускная способность, запросов/сек)
- Error Rate (процент ошибок)
- Database Query Time (время выполнения запросов к БД)

**Для системы рекомендаций:**
- Recommendation Generation Time (время генерации рекомендаций)
- Accuracy Metrics (точность рекомендаций)
- Cold Start Performance (производительность для новых пользователей)

#### 8.2 Сценарии тестирования

1. **Нагрузочное тестирование (Load Testing)**
   - 100 одновременных пользователей
   - Смешанная нагрузка: просмотр, поиск, рекомендации
   - Длительность: 5-10 минут

2. **Стресс-тестирование (Stress Testing)**
   - Постепенное увеличение нагрузки до предела
   - Поиск точки отказа системы

3. **Тестирование рекомендаций**
   - Измерение времени генерации для разных объемов данных
   - Сравнение производительности алгоритмов

#### 8.3 Инструменты
- **Locust** - нагрузочное тестирование API
- **Custom benchmarks** - специализированные тесты рекомендаций
- **MongoDB profiler** - анализ запросов к БД

---

### 9. Ожидаемые результаты

1. **Функциональность**
   - ✅ Полнофункциональный интернет-магазин
   - ✅ Персональные рекомендации для каждого пользователя
   - ✅ Поиск и фильтрация каталога
   - ✅ Корзина и оформление заказов

2. **Производительность**
   - Время ответа API < 200ms для 95% запросов
   - Генерация рекомендаций < 500ms
   - Поддержка 100+ одновременных пользователей
   - Масштабируемость до 100K+ книг и 10K+ пользователей

3. **Качество рекомендаций**
   - Релевантность для пользователей с историей взаимодействий
   - Разнообразие рекомендаций (не только популярные книги)
   - Эффективная обработка cold start

---

### 10. Заключение

Предложенный подход к реализации системы рекомендаций для книжного магазина обеспечивает:

- **Масштабируемость** благодаря MongoDB и асинхронной архитектуре
- **Производительность** через оптимизированные индексы и кэширование
- **Точность рекомендаций** за счет гибридного подхода
- **Гибкость** для дальнейшего развития и экспериментов

Выбранный технологический стек и архитектурные решения позволяют создать современное, высокопроизводительное приложение, готовое к production-использованию.

---

**Дата:** Ноябрь 2024  
**Автор:** [Ваше имя]  
**Версия:** 1.0

